;File DeskDemo1.Asm
;----------------------------------------------------------------

; Demo Desk Ornament 1

; This desk ornament is the simplest ornament possible.  It can
; only create a window and put a string in it.  It does, however,
; show how to handle update events in desk ornaments, as well
; as show how the driver interface works for desk ornaments.

;  Written by Burt Sloane  June 14, 1984


;  Modification History:
;	BAS	6/14/84	  	- Created
;	EHB	10/5/84		- Converted to Mac Development System
;	DKC	12/3/84		- Modified for 128K Macintosh Assembly
;	GUS	05/29/86	- Modified for new equates
;-----------------------------------------------------------------

 	INCLUDE	 	SysEqu.D
 	INCLUDE	 	ToolEqu.D
 	INCLUDE		QuickEqu.D
;	INCLUDE		FSEqu.D
;	INCLUDE		Traps.D
;
; The following Traps are explicitly defined in this example to allow 
; assembly using the minimum amount of memory.  You may simply INCLUDE 
; Traps.D if memory is not a consideration.
;
	.TRAP	_NewWindow	$A913 
	.TRAP	_SetPort	$A873
	.TRAP	_GetPort	$A874
	.TRAP	_DisposWindow	$A914
	.TRAP	_BeginUpdate	$A922
	.TRAP	_EndUpdate	$A923
	.TRAP	_MoveTo		$A893
	.TRAP	_DrawString	$A884
;
; The first four words in a desk accessory determine the behavior of the
; accessory.  These words, described briefly below, are more fully explained
; in the Device Manager and Desk Manager chapters of Inside Macintosh.

; The first word is the flag/descriptor word.  It says whether control calls
; are enabled (+$400), whether the driver needs to be called when the 
; application heap is reinitialized (+$1000), and whether the driver needs 
; periodic calls (+$2000).  A driver must be able to respond to control calls.

; The second word is how often periodic calls should happen in 60ths of a 
; second.  The control routine then gets calls of type accRun.

; The third word is an event mask.  SystemEvent masks the event ID with this
; byte, if it is nonzero, the accessory's control routine is called.

; The fourth word of a driver is the menu ID of the menu installed by this driver.
; When MenuSelect gets called from the application, and the menu hit has a 
; negative ID, it looks around for a matching ID in the fourth word of an 
; active driver.  If it finds it, it sends an accMenu message to the ornament.

OrnEntry
	DC.W		$0400		; ctl-enable only
	DC.W		0		; doesn't need time
	DC.W		$0040		; update events only
	DC.W		0		; no menu

; The next five words are offsets to the accessory's routines: Open, Prime
; Control, Status, and Control.

; 1. Open	Open the ornament.  This gets called each time the application
;		does an OpenDeskAcc call, and must be careful to allocate 
; 		things like the window only once.
; 2. Prime	Do the prime routine.  Used only by drivers, and should
;		point to a 'done' of some sort (like clr.w D0, rts).
; 3. Control	The control entry point.  This is the most important entry 
;		point for an ornament.  It is used to tell the ornament 
;		everthing it needs to know except when to open and close
;		(done thru the open & close entry points).  Examples are:
;			- events (called from SystemEvent, GetNextEvent)
;			- periodic action (called from SystemTask)
;			- cursor changes (called by the desk manager for
;			  active ornaments only)
;			- menu items (called by the menu manager)
;			- cut, copy, paste, undo (called from SystemEdit)
;			- goodbye (called when your code is being purged)
; 4. status	Get status.  Only used in drivers, and should point to a
;		'done' exit point
; 5. close	Close the ornament.  This routine is only called when the
;		application calls CloseDeskAcc. It does not get called 
;		when the application quits.

	DC.W	OrnOpen-OrnEntry	; open routine
	DC.W	OrnDone-OrnEntry	; prime - unused
	DC.W	OrnCtl-OrnEntry	 	; control
	DC.W	OrnDone-OrnEntry	; status - unused
	DC.W	OrnClose-OrnEntry	; close

; The following is an optional title to help find the ornament in memory.
; This demo also uses it as the window title, but it really should go
; look at what appeared in the apple menu to get the title.

OrnTitle
	DC.B	16
	DC.B	'Simple Accessory'
	.ALIGN	2

; Open Routine -- allocate a window if we don't already have one.  
; We will put it in the DCtlWindow field of the Device Control Entry, 
; which lives in the system heap.  Obviously, if there is a window pointer
; in DCtlWindow, we don't need another one. We don't put anything into the 
; window, because an automatic update event is generated by the NewWindow call,
; and we can let our update code handle alawing. Open gets called 
; with a pointer to the Device Control Entry in A1.

OrnOpen
	movem.l A1-A4,-(SP)		; preserve A1-A4
	move.l	A1,A4			; move DCE pointer to a safe register

; Save the application's port because the ROM doesn't do it for us on Open.

	subq.l	#4,SP			; make room for the port
	move.l	SP,-(SP)		; push a pointer to it
	_GetPort			; get it, now it's on top of stack
	tst.l	DCtlWindow(A4)		; do we already have a window?
	
; If so, the window pointer will be saved here, and will be non-zero.

	bne.s	GotAWindow		; if so, don't make a new one

; We didn't have a window, so allocate a new one.  NewWindow takes a bunch
; of parameters, and returns a pointer.  Set it up.

	clr.l	-(SP)			; make room for the new window pointer
	clr.l	-(SP)			; allocate this window on the heap
	pea	tBounds		 	; push the pointer to the boundsRect
	pea	OrnTitle		; push the pointer to the title
	clr.w	-(SP)			; false for the visible flag
	move.w	#documentProc,-(SP)	; use a standard window proc
	moveq	#-1,D0			; get -1 into D0
	move.l	D0,-(SP)		; push behind = -1
	move	#$0100,-(SP)		; true for the goAway box flag
	clr.l	-(SP)			; refCon is 0
	_NewWindow			; do the allocation
	move.l	(SP)+,A0		; pop the new windowPtr off the stack

; Save the window pointer away in the DCE for future reference.  The system
; also uses the DCtlWindow field of the DCE for setting up update events to
; system windows etc.

	move.l  A0,DCtlWindow(A4)	; save the window pointer in the DCE
	move.w	DCtlRefNum(A4),WindowKind(A0)	; mark it as a system window. 

; All drivers, including ornaments, have a negative refnum.  the only way an
; application can know what the refnum of this ornament is is by getting
; it from the WindowKind field.  Applications must have the refnum to do
; CloseDeskAcc()

GotAWindow			; we came here if there was already a window
StdReturn
	_SetPort			; we left the old port on the stack
	movem.l (SP)+,A1-A4		; restore regs
OrnDone
	moveq	#0,D0			; return no error
	rts				; all done, exit

; Close Routine -- To close the ornament, we simply dispose the window to 
; reclaim its storage in the application heap.  When the application exits, 
; The ROM does a general cleanup, which includes reclaiming the entire heap
; and clearing DCtlWindow in all the drivers and ornaments.  This results in 
; a DCE that already exists, but does not have any code or window.

OrnClose
	movem.l A1-A4,-(SP)		; preserve A1-A4
	move.l	A1,A4			; move DCE ptr to A4
	
; 	again we save the port by convention and the same bug as in Open

	subq.l	#4,SP			; make room for the port
	move.l	SP,-(SP)		; push a pointer to it
	_GetPort			; get it, now it's on top of stack

	move.l	DCtlWindow(A4),-(SP)	; push the window
	clr.l	DCtlWindow(A4)		; we no longer have a window.
	
; Clear the pointer.  this is deceptively important.  The system can and will
; do calls to the window manager with the contents of DCtlWindow, and if it 
; has been deallocated, the system will crash miserably.

	_DisposWindow			; dispose it
	bra.s	StdReturn		; all done with close

; OrnCtl handles the control messages, which are the heart of the driver.
; Desk Demo 1 can only handle update calls. We got here with A0 containing 
; the Device Request Block, and A1 containing the Device Control Entry. 
; The Request Block only exists for control calls.

OrnCtl
	move.l	A4,-(SP)		; preserve A4
	move.l	A1,A4			; move DCE ptr to A4
	move.w	CSCode(A0),D0		; get the control opCode
	sub.w	#64,D0			; is it 64?
	beq.s	DoCtlEvent		; yes, it's an event

; all done with the control request, so jump to IODone

CtlDone
	move.l	A4,A1			; put the DCE ptr back in A1
	move.l	(SP)+,A4		; restore A4

	moveq	#0,D0			; return no error
	move.l	JIODone,-(SP)		; jump to IODone
	rts

; DoCtlEvent handles the events received by the ornament.  It handles
; update events only.

DoCtlEvent
	move.l	A3,-(SP)		; save registers
	move.l	CSParam(A0),A3		; get the event pointer
	move.w	EvtNum(A3),D0		; get the event number

; Only check for updates.  any event we don't want we just ignore, because
; other drivers and ornaments will be called with this same event to see if
; they want it

	subq	#6,D0			; is it an update?
	beq.s	ItsUpdate		; if so, go handle it

; its not an event we handle(update), so ignore it

CtlEvtDone
	move.l	(SP)+,A3		; restore registers
	bra	CtlDone


; handle an update event by redrawing the contents of the window

ItsUpdate
	move.l	EvtMessage(A3),-(SP)	; push the window ptr
	_BeginUpdate			; begin the update

	move.l	EvtMessage(A3),-(SP)	; push the window ptr again
	_SetPort			; set the port to our port

	bsr	DrawWindow		; draw the window

	move.l	EvtMessage(A3),-(SP)	; push the window ptr one last time
	_EndUpdate			; end the update

	bra.s	CtlEvtDone

;  draw the window

DrawWindow
	move.w	#5,-(SP)		; move over 5 horizontal
	move.w	#15,-(SP)		; and 15 vertical
	_MoveTo			 	; do the move

	lea	tString,A0
	move.l	A0,-(SP)		; push the pointer to the string
	_DrawString

	rts				; done drawing

tString
	DC.B	14
	DC.B	'This is a test'
	.ALIGN	2

tBounds	DC.W	100,100,140,300	; window bounds

	END

